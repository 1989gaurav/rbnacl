#!/usr/bin/env ruby
module Crypto
  # The Boxer class boxes and unboxes messages
  #
  # This class uses the given public and secret keys to derive a shared key,
  # which is used with the nonce given to encrypt the given messages and
  # decrypt the given ciphertexts.  The same shared key will generated from both
  # pairs of keys, so (pk1, sk2) == (pk2, sk1).  This is how the system works.
  #
  # It is VITALLY important that the nonce is a nonce, i.e. it is a number used
  # only once for any given pair of keys.  If you fail to do this, you
  # compromise the privacy of the the messages encrypted.  Also, bear in mind
  # the property mentioned just above. Give your nonces a different prefix, or
  # have one side use an odd counter and one an even counter.  Just make sure
  # they are different.
  #
  # The ciphertexts generated by this class include a 16-byte authenticator which
  # is checked as part of the decryption.  An invalid authenticator will cause
  # the unbox function to raise.  The authenticator is not a signature.  Once
  # you've looked in the box, you've demonstrated the ability to create
  # arbitrary valid messages, so messages you send are repudiatable.  For
  # non-repudiatable messages, sign them before or after encryption.
  class Boxer

    # Create a new Boxer
    #
    # Sets up the Boxer for deriving the shared key and encrypting and
    # decrypting messages.
    #
    # @param pk [String,Crypto::PublicKey] The public key to encrypt to
    # @param sk [String,Crypto::SecretKey] The secret key to encrypt with
    #
    # @raise [ArgumentError] on invalid keys
    #
    # @return [Crypto::Boxer] The new Boxer, ready to use
    def initialize(pk, sk)
      @pk = pk.respond_to?(:to_bytes) ? pk.to_bytes : pk
      @sk = sk.respond_to?(:to_bytes) ? sk.to_bytes : sk
      raise ArgumentError, "Must provide a valid public key" unless PublicKey.valid?(@pk)
      raise ArgumentError, "Must provide a valid secret key" unless SecretKey.valid?(@sk)
    end

    # Encrypts a message
    #
    # Encrypts the message with the given nonce to the keypair set up when
    # initializing the class.  Make sure the nonce is unique for any given
    # keypair, or you might as well just send plain text.
    #
    # This function takes care of the padding required by the NaCL C API.
    #
    # @param nonce [String] A 24-byte string containing the nonce.
    # @param message [String] The message to be encrypted.
    #
    # @raise [ArgumentError] If the nonce is not valid
    #
    # @return [String] The ciphertext without the nonce prepended.
    def box(nonce, message)
    end

    # Decrypts a ciphertext
    #
    # Decrypts the ciphertext with the given nonce using the keypair setup when
    # initializing the class.
    #
    # This function takes care of the padding required by the NaCL C API.
    #
    # @param nonce [String] A 24-byte string containing the nonce.
    # @param ciphertext [String] The message to be decrypted.
    #
    # @raise [ArgumentError] If the nonce is not valid
    # @raise [Crypto::CryptoError] If the ciphertext cannot be authenticated.
    #
    # @return [String] The decrypted message.
    def unbox(nonce, ciphertext)
    end
  end
end
